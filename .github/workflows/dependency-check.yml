name: Dependency Check

on:
  schedule:
    - cron: '0 12 1-7 * 1'  # First Monday of each month at 12:00 UTC
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:
  check-dependencies:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      - name: Check outdated packages
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const https = require('https');
            
            // Function to get latest version from PyPI with retry
            async function getLatestVersion(packageName, retries = 3) {
              for (let i = 0; i < retries; i++) {
                try {
                  return await new Promise((resolve, reject) => {
                    const url = `https://pypi.org/pypi/${packageName}/json`;
                    const req = https.get(url, { timeout: 10000 }, (res) => {
                      let data = '';
                      res.on('data', (chunk) => data += chunk);
                      res.on('end', () => {
                        try {
                          const json = JSON.parse(data);
                          resolve(json.info.version);
                        } catch (e) {
                          reject(e);
                        }
                      });
                    });
                    req.on('timeout', () => {
                      req.destroy();
                      reject(new Error('Request timeout'));
                    });
                    req.on('error', reject);
                  });
                } catch (e) {
                  if (i === retries - 1) throw e;
                  console.log(`Retry ${i + 1} for ${packageName}: ${e.message}`);
                  await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1))); // Exponential backoff
                }
              }
            }
            
            // Function to parse version spec and extract current version
            function parseVersionSpec(spec) {
              const match = spec.match(/(==|~=|>=|<=|>|<)?(\d+\.\d+\.\d+)/);
              if (match) {
                return {
                  operator: match[1] || '==',
                  version: match[2]
                };
              }
              return null;
            }
            
            // Function to determine update type
            function getUpdateType(currentParts, latestParts) {
              if (latestParts[0] > currentParts[0]) return 'major';
              if (latestParts[1] > currentParts[1]) return 'minor';
              if (latestParts[2] > currentParts[2]) return 'patch';
              return null;
            }
            
            // Parse requirements.txt
            const requirements = fs.readFileSync('requirements.txt', 'utf8').split('\n').filter(line => line.trim() && !line.startsWith('#'));
            console.log(`Found ${requirements.length} requirement lines`);
            const deps = {};
            requirements.forEach(line => {
              const match = line.match(/^([a-zA-Z0-9\-_]+)(.*)$/);
              if (match) {
                const pkg = match[1];
                const versionSpec = match[2].trim();
                deps[pkg] = versionSpec;
              }
            });
            console.log(`Parsed ${Object.keys(deps).length} dependencies`);
            
            const safeUpdates = []; // patch updates
            const compatibilityChecks = []; // minor/major updates
            
            const promises = Object.keys(deps).map(async (name) => {
              try {
                const latest = await getLatestVersion(name);
                const spec = deps[name];
                const parsed = parseVersionSpec(spec);
                if (!parsed) {
                  console.log(`Failed to parse spec for ${name}: ${spec}`);
                  return;
                }
                
                const currentParts = parsed.version.split('.').map(Number);
                const latestParts = latest.split('.').map(Number);
                
                const updateType = getUpdateType(currentParts, latestParts);
                if (!updateType) return; // No update needed
                
                const updateInfo = `${name}: ${parsed.version} â†’ ${latest} (spec: ${spec})`;
                console.log(`Found update: ${updateInfo} type: ${updateType}`);
                
                if (updateType === 'patch') {
                  safeUpdates.push(updateInfo);
                } else {
                  compatibilityChecks.push(updateInfo);
                }
              } catch (e) {
                console.log(`Failed to check ${name}: ${e.message}`);
              }
            });
            
            await Promise.all(promises);
            
            console.log(`Safe updates: ${safeUpdates.length}, Compatibility checks: ${compatibilityChecks.length}`);
            
            // Get all existing open issues with dependencies label once
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: ['dependencies']
            });
            const existingTitles = existingIssues.data.map(issue => issue.title);
            
            // Helper function to close issue if exists
            async function closeIssueIfExists(title) {
              if (existingTitles.includes(title)) {
                const existingIssue = existingIssues.data.find(issue => issue.title === title);
                console.log(`Closing outdated issue #${existingIssue.number}: ${title}`);
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existingIssue.number,
                  state: 'closed'
                });
              }
            }
            
            // Create issue for safe updates (patch)
            if (safeUpdates.length > 0) {
              const title = 'Safe Dependency Updates Available';
              console.log(`Checking for existing issue: ${title}`);
              if (existingTitles.includes(title)) {
                const existingIssue = existingIssues.data.find(issue => issue.title === title);
                console.log(`Closing existing issue #${existingIssue.number}`);
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existingIssue.number,
                  state: 'closed'
                });
              }
              const body = `The following dependencies can be safely updated (patch updates, no compatibility issues expected):\n\n${safeUpdates.map(u => `- ${u}`).join('\n')}\n\nThese updates are backward compatible and can be applied without manual compatibility checks.`;
              console.log('Creating safe updates issue');
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['dependencies', 'maintenance', 'safe-update']
              });
              console.log('Safe updates issue created');
            } else {
              // No safe updates, close any existing safe updates issue
              await closeIssueIfExists('Safe Dependency Updates Available');
            }
            
            // Create issue for compatibility checks (minor/major)
            if (compatibilityChecks.length > 0) {
              const title = 'Dependency Updates Requiring Compatibility Check';
              console.log(`Checking for existing issue: ${title}`);
              if (existingTitles.includes(title)) {
                const existingIssue = existingIssues.data.find(issue => issue.title === title);
                console.log(`Closing existing issue #${existingIssue.number}`);
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: existingIssue.number,
                  state: 'closed'
                });
              }
              const body = `The following dependencies have minor or major version updates available and require manual compatibility checks:\n\n${compatibilityChecks.map(u => `- ${u}`).join('\n')}\n\nThese updates may introduce breaking changes (e.g., 1.3.* to 1.4.*). Please review the changelog and test thoroughly before updating.`;
              console.log('Creating compatibility check issue');
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['dependencies', 'maintenance', 'compatibility-check']
              });
              console.log('Compatibility check issue created');
            } else {
              // No compatibility checks needed, close any existing compatibility check issue
              await closeIssueIfExists('Dependency Updates Requiring Compatibility Check');
            }
